// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

// This sample tool downloads Azure Key Vault Managed certificates
// they can be self-signed certs or certs generated by CAs integrated
// with AKV. The format can be be PKCS12 or PEM.

package main

import (
	"context"
	"encoding/hex"
	"flag"
	"fmt"
	"log"
	"net/url"
	"os"
	"strings"

	"internal/corehelper"
	"internal/utils"

	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/Azure/azure-sdk-for-go/sdk/keyvault/azcertificates"
	"github.com/Azure/azure-sdk-for-go/sdk/keyvault/azsecrets"
)

const (
	ERR_AUTHORIZER                = 2
	ERR_INVALID_ARGUMENT          = 3
	ERR_INVALID_URL               = 4
	ERR_GET_AKV_CERT_SECRET       = 5
	ERR_GET_PEM_PRIVATE_KEY       = 6
	ERR_GET_PEM_CERTIFICATE       = 7
	ERR_CREATE_PEM_FILE           = 8
	ERR_X509_THUMBPRINT           = 9
	ERR_OUTPUTFOLDER_NOT_FOUND    = 10
	ERR_INVALID_AZURE_ENVIRONMENT = 11
	ERR_CREDENTIALS               = 12
)

var (
	validEnvironments = []string{"AZUREPUBLICCLOUD", "AZUREUSGOVERNMENTCLOUD", "AZUREGERMANCLOUD", "AZURECHINACLOUD"}
	certURL           = flag.String("certurl", "", "certificate URL, e.g. \"https://mykeyvault.vault.azure.net/mycertificate\"")
	keyVaultUrl       = ""
	outputFolder      = flag.String("outputfolder", "", "folder where PEM file with certificate and private key will be saved")
	environment       = flag.String("environment", "AZUREPUBLICCLOUD", fmt.Sprintf("valid azure cloud environments: %v", validEnvironments))
	cmdlineversion    = flag.Bool("version", false, "shows current tool version")
	exitCode          = 0
	version           = "0.2.0"
	stdout            = log.New(os.Stdout, "", log.LstdFlags)
	stderr            = log.New(os.Stderr, "", log.LstdFlags)
)

func main() {
	cntx := context.Background()

	// Cleanup and exit handling
	defer func() { exit(cntx, exitCode); os.Exit(exitCode) }()

	flag.Parse()

	if len(os.Args[1:]) < 1 {
		utils.ConsoleOutput(fmt.Sprintf("<error> invalid number of arguments, please execute %v -h or --help for more information", os.Args[0]), stderr)
		exitCode = ERR_INVALID_ARGUMENT
		return
	}

	// Checks if version output is needed
	if *cmdlineversion == true {
		fmt.Println(version)
		exitCode = 0
		return
	}

	// Checks if outputfolder exists
	if _, err := os.Stat(*outputFolder); err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> output folder %v not found", *outputFolder), stderr)
		exitCode = ERR_OUTPUTFOLDER_NOT_FOUND
		return
	}

	// Checks if valid cloud environment was passed
	_, found := utils.FindInSlice(validEnvironments, strings.ToUpper(*environment))
	if !found {
		utils.ConsoleOutput(fmt.Sprintf("<error> invalid azure environment (%v), valid environments are: %v", *environment, validEnvironments), stderr)
		exitCode = ERR_INVALID_AZURE_ENVIRONMENT
		return
	}

	// Creates URL object
	u, err := url.Parse(*certURL)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> an error occurred parsing cert url: %v", err), stderr)
		exitCode = ERR_INVALID_URL
		return
	}
	keyVaultUrl := fmt.Sprintf("%v://%v/", u.Scheme, u.Hostname())

	utils.PrintHeader(fmt.Sprintf("keyvaultcertdownloader - Downloads a certificate from Azure KeyVault saving as PEM file - v%v", version))

	utils.ConsoleOutput(fmt.Sprintf("Output Folder: %v", *outputFolder), stdout)
	utils.ConsoleOutput(fmt.Sprintf("Using Certificate URL: %v", *certURL), stdout)
	utils.ConsoleOutput(fmt.Sprintf("Environment: %v", *environment), stdout)

	//utils.ConsoleOutput("Checking if this session needs to rely on AD Workload Identity webhook", stdout)
	// client := keyvault.New()
	// var authorizer autorest.Authorizer

	tokenFilePath := os.Getenv("AZURE_FEDERATED_TOKEN_FILE")
	if tokenFilePath == "" {
		// utils.ConsoleOutput("Getting authorizer", stdout)
		// os.Setenv("AZURE_ENVIRONMENT", *environment)
		// authorizer, err = kvauth.NewAuthorizerFromEnvironment()
		// if err != nil {
		// 	utils.ConsoleOutput(fmt.Sprintf("<error> unable to create vault authorizer: %v\n", err), stderr)
		// 	exitCode = ERR_AUTHORIZER
		// 	return
		// }

		// utils.ConsoleOutput("Creating KeyVault base client", stdout)

	} else {

	}

	// client.Authorizer = authorizer
	utils.ConsoleOutput("Obtaining credentials", stdout)
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_CREDENTIALS
		return
	}

	utils.ConsoleOutput("Creating clients", stdout)
	azsecretsClient, err := azsecrets.NewClient(keyVaultUrl, cred, nil)
	if err != nil {
		log.Fatalf("failed to create azsecrets client: %v", err)
	}
	azcertsClient, err := azcertificates.NewClient(keyVaultUrl, cred, nil)
	if err != nil {
		log.Fatalf("failed to create azcertificates client: %v", err)
	}

	utils.ConsoleOutput("Getting certificate thumbprint", stdout)
	x509Thumbprint, err := corehelper.GetAKVCertThumbprint(cntx, azcertsClient, *u)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_X509_THUMBPRINT
		return
	}

	hexThumbprint := strings.ToUpper(hex.EncodeToString([]byte(x509Thumbprint)))
	kvCertName := strings.Replace(u.Path, "/", "", 1)
	pemFileName := fmt.Sprintf("%v/%v-%v.PEM", *outputFolder, kvCertName, hexThumbprint)
	utils.ConsoleOutput(fmt.Sprintf("PEM filename: %v", pemFileName), stdout)

	// Checks if certificate needs to be downloaded
	if _, err := os.Stat(pemFileName); err == nil {
		utils.ConsoleOutput(fmt.Sprintf("Certificate %v in key vault is the same as the one already downloaded, exiting...", kvCertName), stdout)
		exitCode = 0
		return
	}

	// Get cert as secret
	utils.ConsoleOutput("Getting certificate as secret", stdout)
	certAKV, err := corehelper.GetAKVCertificate(cntx, azsecretsClient, *u)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> unable to get certificate: %v\n", err), stderr)
		exitCode = ERR_GET_AKV_CERT_SECRET
		return
	}

	utils.ConsoleOutput(fmt.Sprintf("Cert format: %v", *certAKV.ContentType), stdout)

	// Getting PEM Blocks
	var blocks interface{}
	if *certAKV.ContentType == "application/x-pkcs12" {
		blocks, _ = corehelper.GetBlocksFromPCKS12(*certAKV.Value)
	} else if *certAKV.ContentType == "application/x-pem-file" {
		blocks = corehelper.GetBlocksFromPEM([]byte(*certAKV.Value), nil)
	}

	privateKey, err := corehelper.GetPrivateKeyFromPEMBlocks(blocks)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_GET_PEM_PRIVATE_KEY
		return
	}

	certificate, err := corehelper.GetCertificateFromPEMBLocks(blocks)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_GET_PEM_CERTIFICATE
		return
	}

	err = corehelper.WritePEMfile(pemFileName, certificate, privateKey)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_CREATE_PEM_FILE
		return
	}
}

func exit(cntx context.Context, exitCode int) {
	if exitCode == 0 {
		if !*cmdlineversion {
			utils.ConsoleOutput("Execution successfully completed", stdout)
		}
	}
}
