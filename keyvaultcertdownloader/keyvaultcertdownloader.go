// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

// This sample tool downloads Azure Key Vault Managed certificates
// they can be self-signed certs or certs generated by CAs integrated
// with AKV. The format can be be PKCS12 or PEM.

package main

import (
	"context"
	"encoding/hex"
	"flag"
	"fmt"
	"net/url"
	"os"
	"strings"

	"internal/corehelper"
	"internal/utils"
)

var (
	validEnvironments        = []string{"AZUREPUBLICCLOUD", "AZUREUSGOVERNMENTCLOUD", "AZURECHINACLOUD", "CUSTOMCLOUD"}
	certURL                  = flag.String("certurl", "", "certificate URL, e.g. \"https://mykeyvault.vault.azure.net/mycertificate\"")
	outputFolder             = flag.String("outputfolder", "", "folder where PEM file with certificate and private key will be saved")
	environment              = flag.String("environment", "AZUREPUBLICCLOUD", fmt.Sprintf("valid azure cloud environments: %v", validEnvironments))
	cmdlineversion           = flag.Bool("version", false, "shows current tool version")
	managedIdentityId        = flag.String("managed-identity-id", "", "uses user managed identities (accepts resource id or client id)")
	useSystemManagedIdentity = flag.Bool("use-system-managed-identity", false, "uses system managed identity")
	cloudConfigFile          = flag.String("custom-cloudconfig-file", "", "passes a custom cloud configuration to the sdk for use with non-public azure clouds, only used for CUSTOMCLOUD environment")
	exitCode                 = 0
	version                  = "1.5.0"
)

func main() {
	cntx := context.Background()

	// Cleanup and exit handling
	defer func() { exit(cntx, exitCode); os.Exit(exitCode) }()

	flag.Parse()

	if len(os.Args[1:]) < 1 {
		utils.ConsoleOutput(fmt.Sprintf("<error> invalid number of arguments, please execute %v -h or --help for more information", os.Args[0]), corehelper.Stderr)
		exitCode = corehelper.ERR_INVALID_ARGUMENT
		return
	}

	// Checks if version output is needed
	if *cmdlineversion {
		fmt.Println(version)
		exitCode = 0
		return
	}

	// Checks if outputfolder exists
	if _, err := os.Stat(*outputFolder); err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> output folder %v not found", *outputFolder), corehelper.Stderr)
		exitCode = corehelper.ERR_OUTPUTFOLDER_NOT_FOUND
		return
	}

	// Checks if valid cloud environment was passed
	_, found := utils.FindInSlice(validEnvironments, strings.ToUpper(*environment))
	if !found {
		utils.ConsoleOutput(fmt.Sprintf("<error> invalid azure environment (%v), valid environments are: %v", *environment, validEnvironments), corehelper.Stderr)
		exitCode = corehelper.ERR_INVALID_AZURE_ENVIRONMENT
		return
	}

	// Checks if both user managed identity and system managed identities were set
	if *managedIdentityId != "" && *useSystemManagedIdentity {
		utils.ConsoleOutput("<error> invalid authentication options, user and system assigned managed identities arguments cannot be used at the same time", corehelper.Stderr)
		exitCode = corehelper.ERR_INVALID_CREDENTIAL_ARGS
		return
	}

	// Checks if custom cloud file is only passed when custom cloud option is used
	if strings.ToUpper(*environment) != "CUSTOMCLOUD" && *cloudConfigFile != "" {
		utils.ConsoleOutput("<error> cloud config file is only supported for custom cloud", corehelper.Stderr)
		exitCode = corehelper.ERR_CLOUD_CONFIG_FILE_ONLY_FOR_CUSTOM_CLOUD
		return
	}

	// Checks if cloud config file is passed when using custom cloud
	if strings.ToUpper(*environment) == "CUSTOMCLOUD" && *cloudConfigFile == "" {
		utils.ConsoleOutput("<error> cloud config file is required for custom cloud", corehelper.Stderr)
		exitCode = corehelper.ERR_CLOUD_CONFIG_FILE_REQUIRED_FOR_CUSTOM_CLOUD
		return
	}

	if strings.ToUpper(*environment) == "CUSTOMCLOUD" && *cloudConfigFile != "" {
		// Checks if custom cloud config file exists
		if _, err := os.Stat(*cloudConfigFile); os.IsNotExist(err) {
			utils.ConsoleOutput("<error> cloud config file not found", corehelper.Stderr)
			exitCode = corehelper.ERR_CLOUD_CONFIG_FILE_NOT_FOUND
			return
		}
	}

	// Creates URL object
	u, err := url.Parse(*certURL)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> an error occurred parsing cert url: %v", err), corehelper.Stderr)
		exitCode = corehelper.ERR_INVALID_URL
		return
	}

	keyVaultUrl := fmt.Sprintf("%v://%v/", u.Scheme, u.Hostname())

	utils.PrintHeader(fmt.Sprintf("keyvaultcertdownloader - Downloads a certificate from Azure KeyVault saving as PEM file - v%v", version))

	utils.ConsoleOutput(fmt.Sprintf("Output Folder: %v", *outputFolder), corehelper.Stdout)
	utils.ConsoleOutput(fmt.Sprintf("Using Certificate URL: %v", *certURL), corehelper.Stdout)
	utils.ConsoleOutput(fmt.Sprintf("Environment: %v", *environment), corehelper.Stdout)

	utils.ConsoleOutput("Checking if this session needs to rely on AD Workload Identity webhook", corehelper.Stdout)

	// Getting token credentials to be used by various clients
	cred, err := corehelper.GetTokenCredentials(*managedIdentityId, *useSystemManagedIdentity)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> failed to obtain token credentials: %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_CREDENTIALS
		return
	}

	// Creating clients
	utils.ConsoleOutput("Creating clients", corehelper.Stdout)
	azsecretsClient, err := corehelper.GetSecretsClient(keyVaultUrl, *environment, *cloudConfigFile, cred)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> failed to create azsecrets client: %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_CREDENTIALS
		return
	}

	azcertsClient, err := corehelper.GetCertsClient(keyVaultUrl, *environment, *cloudConfigFile, cred)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> failed to create azcertificates client: %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_CREDENTIALS
		return
	}

	utils.ConsoleOutput("Getting certificate thumbprint", corehelper.Stdout)
	x509Thumbprint, err := corehelper.GetAKVCertThumbprint(cntx, &azcertsClient, *u)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_X509_THUMBPRINT
		return
	}

	hexThumbprint := strings.ToUpper(hex.EncodeToString([]byte(x509Thumbprint)))
	kvCertName := strings.Replace(u.Path, "/", "", 1)
	pemFileName := fmt.Sprintf("%v/%v-%v.PEM", *outputFolder, kvCertName, hexThumbprint)
	utils.ConsoleOutput(fmt.Sprintf("PEM filename: %v", pemFileName), corehelper.Stdout)

	// Checks if certificate needs to be downloaded
	if _, err := os.Stat(pemFileName); err == nil {
		utils.ConsoleOutput(fmt.Sprintf("Certificate %v in key vault is the same as the one already downloaded, exiting...", kvCertName), corehelper.Stdout)
		exitCode = 0
		return
	}

	// Get cert as secret
	utils.ConsoleOutput("Getting certificate as secret", corehelper.Stdout)
	certAKV, err := corehelper.GetAKVCertificate(cntx, &azsecretsClient, *u)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> unable to get certificate: %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_GET_AKV_CERT_SECRET
		return
	}

	utils.ConsoleOutput(fmt.Sprintf("Cert format: %v", *certAKV.ContentType), corehelper.Stdout)

	// Getting PEM Blocks
	var blocks interface{}
	if *certAKV.ContentType == "application/x-pkcs12" {
		blocks, _ = corehelper.GetBlocksFromPCKS12(*certAKV.Value)
	} else if *certAKV.ContentType == "application/x-pem-file" {
		blocks = corehelper.GetBlocksFromPEM([]byte(*certAKV.Value), nil)
	}

	privateKey, err := corehelper.GetPrivateKeyFromPEMBlocks(blocks)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_GET_PEM_PRIVATE_KEY
		return
	}

	certificate, err := corehelper.GetCertificateFromPEMBLocks(blocks)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_GET_PEM_CERTIFICATE
		return
	}

	err = corehelper.WritePEMfile(pemFileName, certificate, privateKey)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), corehelper.Stderr)
		exitCode = corehelper.ERR_CREATE_PEM_FILE
		return
	}
}

func exit(cntx context.Context, exitCode int) {
	if exitCode == 0 {
		if !*cmdlineversion {
			utils.ConsoleOutput("Execution successfully completed", corehelper.Stdout)
		}
	}
}
