// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

// This sample tool downloads Azure Key Vault Managed certificates
// they can be self-signed certs or certs generated by CAs integrated
// with AKV. The format can be be PKCS12 or PEM.

package main

import (
	"context"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"encoding/pem"
	"flag"
	"fmt"
	"log"
	"net/url"
	"os"
	"strings"

	"github.com/Azure/azure-sdk-for-go/profiles/latest/keyvault/keyvault"
	kvauth "github.com/Azure/azure-sdk-for-go/services/keyvault/auth"
	"github.com/microsoft/keyvaultcertdownloader/src/internal/utils"
	"software.sslmate.com/src/go-pkcs12"
)

const (
	ERR_AUTHORIZER                = 2
	ERR_INVALID_ARGUMENT          = 3
	ERR_INVALID_URL               = 4
	ERR_GET_AKV_CERT_SECRET       = 5
	ERR_GET_PEM_PRIVATE_KEY       = 6
	ERR_GET_PEM_CERTIFICATE       = 7
	ERR_CREATE_PEM_FILE           = 8
	ERR_X509_THUMBPRINT           = 9
	ERR_OUTPUTFOLDER_NOT_FOUND    = 10
	ERR_INVALID_AZURE_ENVIRONMENT = 11
)

var (
	validEnvironments = []string{"AZUREPUBLICCLOUD", "AZUREUSGOVERNMENTCLOUD", "AZUREGERMANCLOUD", "AZURECHINACLOUD"}
	certURL           = flag.String("certurl", "", "certificate URL, e.g. \"https://mykeyvault.vault.azure.net/mycertificate\"")
	outputFolder      = flag.String("outputfolder", "", "folder where PEM file with certificate and private key will be saved")
	environment       = flag.String("environment", "AZUREPUBLICCLOUD", fmt.Sprintf("valid azure cloud environments: %v", validEnvironments))
	exitCode          = 0
	version           = "0.1.1"
	stdout            = log.New(os.Stdout, "", log.LstdFlags)
	stderr            = log.New(os.Stderr, "", log.LstdFlags)
)

func main() {
	cntx := context.Background()

	// Cleanup and exit handling
	defer func() { exit(cntx, exitCode); os.Exit(exitCode) }()

	flag.Parse()

	if len(os.Args[1:]) < 2 {
		utils.ConsoleOutput(fmt.Sprintf("<error> invalid number of arguments, please execute %v -h or --help for more information", os.Args[0]), stderr)
		exitCode = ERR_INVALID_ARGUMENT
		return
	}

	// Checks if outputfolder exists
	if _, err := os.Stat(*outputFolder); err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> output folder %v not found", *outputFolder), stderr)
		exitCode = ERR_OUTPUTFOLDER_NOT_FOUND
		return
	}

	// Checks if valid cloud environment was passed
	_, found := utils.FindInSlice(validEnvironments, strings.ToUpper(*environment))
	if !found {
		utils.ConsoleOutput(fmt.Sprintf("<error> invalid azure environment (%v), valid environments are: %v", *environment, validEnvironments), stderr)
		exitCode = ERR_INVALID_AZURE_ENVIRONMENT
		return
	}

	// Creates URL object
	u, err := url.Parse(*certURL)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> an error occurred parsing cert url: %v", err), stderr)
		exitCode = ERR_INVALID_URL
		return
	}

	utils.PrintHeader(fmt.Sprintf("keyvaultcertdownloader - Downloads a certificate from Azure KeyVault saving as PEM file - v%v", version))

	utils.ConsoleOutput(fmt.Sprintf("Output Folder: %v", *outputFolder), stdout)
	utils.ConsoleOutput(fmt.Sprintf("Using Certificate URL: %v", *certURL), stdout)
	utils.ConsoleOutput(fmt.Sprintf("Environment: %v", *environment), stdout)

	utils.ConsoleOutput("Getting authorizer", stdout)
	os.Setenv("AZURE_ENVIRONMENT", *environment)
	authorizer, err := kvauth.NewAuthorizerFromEnvironment()
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> unable to create vault authorizer: %v\n", err), stderr)
		exitCode = ERR_AUTHORIZER
		return
	}

	utils.ConsoleOutput("Creating KeyVault base client", stdout)
	client := keyvault.New()
	client.Authorizer = authorizer

	utils.ConsoleOutput("Getting certificate thumbprint", stdout)
	x509Thumbprint, err := getAKVCertThumbprint(cntx, client, *u)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_X509_THUMBPRINT
		return
	}

	hexThumbprint := strings.ToUpper(hex.EncodeToString([]byte(x509Thumbprint)))
	kvCertName := strings.Replace(u.Path, "/", "", 1)
	pemFileName := fmt.Sprintf("%v/%v-%v.PEM", *outputFolder, kvCertName, hexThumbprint)
	utils.ConsoleOutput(fmt.Sprintf("PEM filename: %v", pemFileName), stdout)

	// Checks if certificate needs to be downloaded
	if _, err := os.Stat(pemFileName); err == nil {
		utils.ConsoleOutput(fmt.Sprintf("Certificate %v in key vault is the same as the one already downloaded, exiting...", kvCertName), stdout)
		exitCode = 0
		return
	}

	// Get cert as secret
	utils.ConsoleOutput("Getting certificate as secret", stdout)
	certAKV, err := getAKVCertificate(cntx, client, *u)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> unable to get certificate: %v\n", err), stderr)
		exitCode = ERR_GET_AKV_CERT_SECRET
		return
	}

	utils.ConsoleOutput(fmt.Sprintf("Cert format: %v", *certAKV.ContentType), stdout)

	// Getting PEM Blocks
	var blocks interface{}
	if *certAKV.ContentType == "application/x-pkcs12" {
		blocks, _ = getBlocksFromPCKS12(*certAKV.Value)
	} else if *certAKV.ContentType == "application/x-pem-file" {
		blocks = getBlocksFromPEM([]byte(*certAKV.Value), nil)
	}

	privateKey, err := getPrivateKeyFromPEMBlocks(blocks)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_GET_PEM_PRIVATE_KEY
		return
	}

	certificate, err := getCertificateFromPEMBLocks(blocks)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_GET_PEM_CERTIFICATE
		return
	}

	err = writePEMfile(pemFileName, certificate, privateKey)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("<error> %v\n", err), stderr)
		exitCode = ERR_CREATE_PEM_FILE
		return
	}
}

func exit(cntx context.Context, exitCode int) {
	if exitCode == 0 {
		utils.ConsoleOutput("Execution successfully completed", stdout)
	}
}

func getBlocksFromPEM(data []byte, blocks []*pem.Block) []*pem.Block {
	block, rest := pem.Decode(data)
	if block == nil {
		return blocks
	}

	blocks = append(blocks, block)
	return getBlocksFromPEM(rest, blocks)
}

func getBlocksFromPCKS12(certString string) (blocks []*pem.Block, err error) {
	decodedData, _ := base64.StdEncoding.DecodeString(certString)

	// Decoding PKCS12 blob
	privateKey, firstCert, certList, err := pkcs12.DecodeChain(decodedData, "")
	if err != nil {
		return nil, err
	}

	// Extracting private key and creating private key pem.block
	privateKeyBytes, err := x509.MarshalPKCS8PrivateKey(privateKey)
	if err != nil {
		return nil, err
	}
	blocks = append(blocks, &pem.Block{Type: "PRIVATE KEY", Bytes: privateKeyBytes})

	// Checking if first certificate is non-CA cert and converting to pem.block if true
	if !firstCert.IsCA {
		blocks = append(blocks, &pem.Block{Type: "CERTIFICATE", Bytes: firstCert.Raw})
		return blocks, nil
	}

	// Iterating over the caCerts list since we cannot assume that cert returned by pkcs12.DecodeChain
	// is the leaf certificate
	for _, cert := range certList {
		if !cert.IsCA {
			blocks = append(blocks, &pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
			break
		}
	}

	return blocks, nil
}

func getAKVCertificateBundle(cntx context.Context, client keyvault.BaseClient, certURL url.URL) (keyvault.CertificateBundle, error) {
	cert, err := client.GetCertificate(cntx, fmt.Sprintf("https://%v", certURL.Host), strings.Replace(certURL.Path, "/", "", 1), "")
	if err != nil {
		return keyvault.CertificateBundle{}, err
	}

	return cert, nil
}

func getAKVCertificate(cntx context.Context, client keyvault.BaseClient, certURL url.URL) (keyvault.SecretBundle, error) {
	certSecret, err := client.GetSecret(cntx, fmt.Sprintf("https://%v", certURL.Host), strings.Replace(certURL.Path, "/", "", 1), "")
	if err != nil {
		return keyvault.SecretBundle{}, err
	}

	return certSecret, nil
}

func writePEMfile(filename string, certificate, privateKey interface{}) error {
	f, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("unable to create pem file %v: %v", filename, err)
	}
	defer f.Close()

	err = pem.Encode(f, &pem.Block{Type: certificate.(*pem.Block).Type, Bytes: certificate.(*pem.Block).Bytes})
	if err != nil {
		return fmt.Errorf("an error ocurred writting certificate to pem file %v:", err)
	}

	err = pem.Encode(f, &pem.Block{Type: privateKey.(*pem.Block).Type, Bytes: privateKey.(*pem.Block).Bytes})
	if err != nil {
		return fmt.Errorf("an error ocurred writting private key to pem file %v:", err)
	}

	return nil
}

func getCertificateFromPEMBLocks(blocks interface{}) (certificate interface{}, err error) {
	for _, b := range blocks.([]*pem.Block) {
		if strings.Contains(b.Type, "CERTIFICATE") {
			x509cert, err := x509.ParseCertificate(b.Bytes)
			if err != nil {
				return nil, fmt.Errorf("failed to parse certificate: %v", err)
			}
			if x509cert.IsCA == false {
				certificate = b
				break
			}
		}
	}
	if certificate == nil {
		return nil, fmt.Errorf("unable to find non-CA certificate")
	}

	return certificate, nil
}

func getPrivateKeyFromPEMBlocks(blocks interface{}) (privateKey interface{}, err error) {
	for _, b := range blocks.([]*pem.Block) {
		if strings.Contains(b.Type, "PRIVATE KEY") {
			privateKey = b
			break
		}
	}
	if privateKey == nil {
		return nil, fmt.Errorf("unable to find private key")
	}

	return privateKey, nil
}

func getAKVCertThumbprint(cntx context.Context, client keyvault.BaseClient, certURL url.URL) (thumbprint string, err error) {
	certBundle, err := getAKVCertificateBundle(cntx, client, certURL)
	if err != nil {
		return "", fmt.Errorf("unable to get certificate bundle: %v", err)
	}

	return *certBundle.X509Thumbprint, nil
}
